# スタックマシン
```
・構文木をアセンブリに変換する方法について学ぶ
```
- なぜ加減算と同じ方法でアセンブリに変換できないのか
```
・加減算のできるコンパイラではraxを結果のレジスタとして、中間的な計算結果を1つだけ保持していた。
・しかし、乗除算ができるコンパイラの場合、計算結果を2つ保持する必要がある。たとえば2*3 + 4*5
・このような計算を行うのに適しているのがスタックマシン
```

## スタックマシンの概念
```
スタックマシン
    ・スタックをデータ保存領域として持っているコンピュータ
    ・stackにはpushとpopを行う
    ・LIFO:後入れ先出し。新しい要素ほど先に出す

スタックマシンにおける演算命令
    ・スタックトップ（次に取り出す要素）の要素に作用する
    ・ADDなら2つpopして、加算して結果をstackにpush
    ・ADDはスタックトップの2要素を、加算した1つの要素で置き換える命令
    ・SUB,MUL,DIVも同様
    ・逆ポーランド記法みたい
    ・PUSH命令は引数の要素をスタックトップに積む
    ・POPならスタックトップから要素を1つ取り除き捨てる
    ・計算結果は、スタックトップの値になる
```

- 2×3 + 4×5の計算
```asm
PUSH 2
PUSH 3
MUL
PUSH 4
PUSH 5
MUL
ADD
```

- CISCとRISC
```
x86-64は、典型的なCISCと呼ばれるスタイルのプロセッサ

CICSプロセッサ
    ・機械語の演算がレジスタだけでなく、メモリアドレスを取ることが可能
    ・機械語命令の長さが可変長
    ・複雑な操作を1命令で行う命令を多く備える
    
RISCプロセッサ
    ・演算は必ずレジスタ間で行う
    ・メモリに対する操作はレジスタへのロードとレジスタからのストアのみ
    ・機械語命令の長さは固定長
    ・コンパイラが生成する簡単な命令のみ備える
    ・特定の整数レジスタが特別な使われ方をするなんてことがない

・x86-64以外の主要なプロセッサはほとんどRISCがベース

x86-64が生き残った理由
    ・IntelはCPUの命令デコーダでx86命令を内部的にRISCに変換して、x86を内部的にRISCプロセッサ化したから
```

## スタックマシンへのコンパイル
```
・抽象構文木をスタックマシンのコードに変換したい
⇒四則演算式をパースして、x86-64命令を使ったスタックマシンにコンパイルして実行可能

・スタックマシンでは部分式を計算すると、結果の1つの値がスタックトップに残る
```

- 木をコンパイル
```
1. 左の部分木をコンパイル
2. 右の部分木をコンパイル
3. スタックの2つの値をそれらを加算した結果で置き換えるコードを出力

・木を下りながら、アセンブリを出力していけばいい
```

- 具体的に考える(2+3*4)
```
1. 木のルートのノードを受け取る
2. 左の部分木をコンパイル => 数値の2をコンパイル PUSH 2
3. 右の部分木をコンパイル 
4. 部分木の左側をコンパイル　=> PUSH 3
5. 部分木の右側をコンパイル　=> PUSH 4
6. 再帰呼び出しを戻る => MUL => スタックトップの2つを置き換え
7. 再帰呼び出しを戻る => ADD => スタックトップを出力
```

## x86-64におけるスタックマシンの実現方法
```
・実際のx86-64はスタックマシンではなくレジスタマシン
・そのため演算は通常2つのレジスタ間に対して定義されている
・そのため、レジスタマシンでスタックマシンをエミュレートする必要あり
⇒スタックマシンで1命令になっているものを複数の命令を使って実装
```
- 具体的な手法
```
1. スタックの先頭の要素を指すレジスタを1つ用意（スタックポインタ
2. popしたい時:スタックポインタの指す要素を取り出し、スタックポインタを取り出した分だけ変更
3. pushしたい時: スタックポインタの指す要素を入れる分だけ変更してから、それが指すメモリ領域に書き込む

※x86-64のRSPレジスタはスタックポインタとして使うことを念頭に置いて設計されている
⇒x86-64のpushやpopは暗黙的にRSPをスタックポインタとして使い、その値を変更しつつ、RSPが指しているメモリにアクセスする
```
- 1+2
```
push 1
push 2

// 計算(popする時はRSPが指しているメモリにアクセスできる)
pop rdi
pop rax
add rdi, rax

// 結果(rax)をrspにpush
push rax
```
- 2×3 + 4×5(1個目に結果が入る)
```
// 2*3
push 2
push 3

pop rdi
pop rax
mul rax, rdi
push rax

// 4*5
push 4
push 5
pop rdi
pop rax
mul rax, rdi
push rax

// 6 + 20
pop rdi
pop rax
add rax, rdi
push rax

```
- C言語で実装
```c
void gen(Node *node){
    if(node->kind == ND_NUM){
        printf("    push %d\n", node->val);
        return;
    }
    gen(node->lhs);
    gen(node->rhs);

    printf("    pop rdi\n");
    printf("    pop rax\n");

    switch(node->kind){
        case ND_ADD;
            printf("    add rax, rdi\n");
            break;
        case ND_SUB;
            printf("    sub rax, rdi\n");
            break;
        case ND_MUL;
            printf("    imul rax, rdi\n");
            break;
        case ND_DIV;
        printf("    cqo\n")
            printf("    idiv rdi\n");
            break;
    }

    pritnf("    push rax\n");
}
```
- 説明
```
idiv, imul
    符号あり、乗算、除算

cqo
    ・RAXに入っている64bitの値を128bitに伸ばして、RDXとRAXにsetする
    ・デフォルトで、idivは暗黙のうちにRDXとRAXを取って、組み合わせたものを128bit整数とみなし、それを引数のレジスタの64bitで割る。
    ・そして、商をRAXに余りをRDXにセットする。
    ・つまり、RAX / RDIをやりたいなら、まずRAXを引き延ばし、そこからidivを使う必要がある
```
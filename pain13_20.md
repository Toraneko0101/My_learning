# 13章
- 配列
- 要素数が必要
```c
#include <stdio.h>

int main(void){
    //残りには0が代入される
    //要素数を省略すると{}内の個数が要素数となる
    int array[10] = {100, 67, 45};
    array[2] = 100;
    printf("%d\n", array[2]);
    array[2] ++;
    printf("%d\n", array[2]);
    printf("%d\n", array[9]);
    printf("------------\n");

    //配列に対してループを回す
    int length = sizeof(array) / sizeof(array[0]);
    for (int i=0; i<length; i++){
        printf("%d\n", array[i]);
    }
    return 0;
}
```
- memcpyで配列をコピー
- copy元がcopy先より長いとはみ出してバッファオーバーフローするので注意
```c
#include <stdio.h>
#include <string.h>

int main(void){

    //memcpy(to_copy, from_copy, 配列全体のsize)

    int array1[5];
    int array2[5];
    
    for (int i=0; i < sizeof(array1) / 4; i++){
        array1[i] = i;
    }

    memcpy(array2, array1, sizeof(array1));

    for (int i=0; i < sizeof(array2) / 4; i++){
        printf("%d\n", array2[i]);
    }

    return 0;
}
```

## 練習問題
### 1
```
配列
```
### 2
```
平均値の算出
```
### 3
```
forループを逆から
```

### 4
```
変数をまとめて扱える
```

# 14章
- 文字コード
```c
#include <stdio.h>
#include <ctype.h>

int main(void){
    char c = 'A' + 32;
    printf("%c\n", c);

    // '0', '1'...という順に並んでいることを利用し、intにする
    //数字以外は-1にする
    char d = 'A';
    int digit = -1;
    if (d >= '0' && d <= '9'){
        digit = d - '0';
    }
    printf("%d\n", digit);

    //ライブラリを使ったパターン
    char e = '0';
    char judge;

    if (!isalpha(e)){
       judge = '!'; 
    }else{
        judge = e;
    }
    printf("%c\n", judge);

    return 0;
}
```
- 文字列 = 文字変数の配列?
- 終端文字:\0文字数を記憶するために使用
```c
#include <stdio.h>

int main(void){
    //EOFが入るので、1つ要素数が多くなる
    //なお、配列の初期化時に、要素を省略した場合、残りには0が入り、それがEOSとなる
    //EOSを書いた場合は、要素数を省略可能
    char str[6] = {'M', 'A', 'T', 'T', 'O', '\0'};
    printf("%s\n", str);

    //文字数リテラル
    //初期化時にしか使えない
    //後から代入した場合は以下のようにする
    char str1[] = "MATTO";
    str1[2] = 'R';
    str1[3] = 'I';
    printf("%s\n", str1);
    return 0;
}
```
- 数値への変換
- stdlib.hが必要
```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
    //atoiでは+-が付いた符号付きの数字も変換可能
    char str[] = "-1450";
    int digit = atoi(str);
    printf("%d\n", digit * 2);
    //atofは実数変換
    char str1[] = "-3.14159";
    float f = atof(str1);
    printf("%f\n", 2*2*f);
    return 0;
}
```
- 文字列のコピー
```c
#include <stdio.h>
#include <string.h>

int main(void){

    //strcpy(to_copy, from_copy);
    char str[10];
    char str1[10];
    //文字列のコピーに使用:こうすれば初期化以外にも使える
    strcpy(str, "NEKONEKO");
    printf("%s\n", str);

    //strncpy:先頭から指定された文字数のみコピー
    //コピー元にEOSが入っていない可能性があるので\0を付けること
    strncpy(str1, "NEKONEKO", 3);
    str1[3] = '\0';
    printf("%s\n", str1);
    return 0;
}
```
- 文字列の連結
```c
#include <stdio.h>
#include <string.h>

int main(void){
    char str[] = "Nekoneko""Inudayo";
    printf("%s\n", str);
    
    //配列に記憶された文字列を連結する場合
    //stringを操作するときはたいてい,string.h
    char str1[100] = "Onigiri";
    char str2[] = "Mogumogu";
    strcat(str1, str2);
    printf("%s\n", str1);

    //sprintf
    //結果を配列の中に記憶する:便利
    char str3[100];
    char str4[] = "Nezumi";
    char str5[] = " ate Lion";
    int i = 3;
    sprintf(str3, "%s%s%d", str4, str5, i);
    printf("%s\n", str3);
    
    return 0;

}
```
- 文字列の入力 & 文字数のカウント
```c
#include <stdio.h>
#include <string.h>

int main(void){
    //spaceが区切り記号とみなされることに注意
    //桁数を指定しないとバッファオーバーフローのもとになる
    char str[10];
    scanf("%9s", str);
    printf("%s\n",str);
    int i = 0;
    //文字数のカウント(EOFが出てくるまでカウントアップ)
    for (i=0; str[i] != '\0'; i++){

    }
    printf("%d\n", i);
    //strlenでも同じことができる
    i = strlen(str);
    printf("%d\n", i);
    return 0;
}
```
- 文字列比較
```c
#include <stdio.h>
#include <string.h>

int main(void){
    //配列の場合、==でメモリの比較になるので使えない
    //EOFまで同じか比較するためにloopを書く場合は、注意が必要

    //等しいなら0。プラスマイナスは文字コードに関係する
    int judge = strcmp("Neko", "Neko");
    // 三項演算子
    printf("%s\n", judge == 0 ? "True" : "False");
    return 0;
}
```
- まとめ
```
scanf("%s", str); //終端文字は自動的に入る
atoi(str), atof(str); //数値、実数に変換
strcpy(to_str, from_str); //コピー
strncpy(to_str, from_str, num); //先頭からnumだけコピー
sprintf(str, "%s%s", str1, str2); //printfのようなフォーマットで表示。連結にも使用可能
strlen(str); //文字数
strcmp(str1, str2); //比較:返り値はTrueなら0

```
## 練習問題14

### 1
```
A. 文字コード
A. 終端文字
```

### 2
```
AからZまでアルファベットを表示
```

### 3
```c
#include <stdio.h>
#include <string.h>

int main(void){
    char lastname[100];
    char firstname[100];
    char fullname[200];
    printf("苗字:");
    scanf("%100s", lastname);
    printf("名前:");
    scanf("%100s", firstname);

    sprintf(fullname, "%s %s", lastname, firstname);
    printf("%s\n", fullname);
}
```
### 4
```
文字列の長さを末尾の\0で把握するため
```

# 15章
- CMOS
```
BIOSに関する情報が記憶された半導体メモリ
BIOSのUpdate時には、このCMOSの情報を書き換える。
主にクロック数などが保存されている
```
- メモリ
```
・onかoffか。電圧の違いで、1,0を判定している
・CPUが1回で扱う2進数の桁数がビット数
・64bitなら64個。つまり8byte

・1byte(8bit)毎に番号が付けられている
・変数名->コンパイル->番号->特定の1byteを指す

```
- 変数のメモリ上の番号を表示する
- アドレス：変数につけられたメモリ上での番号(0xFFFFFFFFFFFF)
- &で変数のアドレスを参照する
```c
#include <stdio.h>

int main(void){
    int i, j, k;
    //iのmemoryを参照
    //例) 0x7ffd481ff824
    // int型は4byteなので、4番だけずれた連番が与えられている
    // アドレスさえ分かっていればいいので、必ずしも連番だとは限らない
    printf("%p\n", &i); 
    printf("%p\n", &j); 
    printf("%p\n", &k); 
    return 0;
}
```
- 配列のアドレス参照
- 配列名 = 先頭のアドレスになるので&は要らない
```c
#include <stdio.h>

int main(void){

    int array[10];
    printf("array___(%p)\n", array);
    printf("array[0](%p)\n", &array[0]);
    printf("array[1](%p)\n", &array[1]);
    printf("array[2](%p)\n", &array[2]);

    return 0;
}
```
- 結果
```
array___(0x7fff9c043560)
array[0](0x7fff9c043560)
array[1](0x7fff9c043564)
array[2](0x7fff9c043568)
```
- まとめ
```
・配列名 = 配列の最初の要素のアドレス
・index = 配列名のアドレス + 要素番号のメモリを参照
★配列名のアドレス + index * 型サイズで要素の中身にアクセス可能
・Cのような静的型付け言語が、listに型の違う要素を入れられないのはそのためなのかな?
```
- &つき変数について
```
&演算子:変数のアドレスを求めることが可能
使い道:
    ・引数で渡せるのは数値
    ・変数に記憶されている値が、
    呼び出された関数の実引数にコピーされて、使われる
    ・つまり関数内で値のコピーを変化させても、呼び出し先の変数は変わらない
    ・&演算子で参照渡しを行えば、関数が変数のアドレスを把握し、直接それを書き換えることが可能となる
    ・scanfも関数なので、直前に宣言した変数の中身を変化させるため、&を用いていた。&を書かないとコピーになるので
    ・文字列の場合は、配列名が配列の最初の要素のアドレスを意味していたため、&が要らなかった
    ・第二引数にアドレスを指定しているのは変わらない
```
- つまり、これでも可能
```c
#include <stdio.h>

int main(void){

    char str[256];
    // str = &str[0]
    scanf("%10s", &str[0]);
    printf("%s\n", str);
    return 0;
}
```
- 配列の途中から入力させる
```c
#include <stdio.h>

int main(void){

    char str[256] = "NEKODAYO";
    //scanfは第二引数のアドレスから文字列を入力するので、以下では9文字から入力され、
    //\0が8文字目までにないので結合される
    //なお、アドレス値を0xff...のように直接指定するのはできない模様
    scanf("%10s", &str[8]);
    printf("%s\n", str);
    return 0;
}
```
- ポインタ
```
ポインタ:アドレスの値を記憶することの変数
    ポインタ型：他の型から作り出される派生型
    ポインタ値：ポインタ型で扱える数値->アドレス
    ポインタ変数：ポインタ型で宣言されたポインタ変数を記憶できる変数

アドレス(整数値)を記憶する型が他の型と合体しなければいけない理由
    ・int, double, char等の型は全てサイズが違うため
    ・intなら4byte分をまとめて取り出す必要があるため
    ・どんな型のアドレスだったのかわからないと引き出せない

voidポインタ
    どんな変数のアドレスでも記憶可能
    もともとの変数の型がわからないので値を取り出せない

ポインタ値
    int型に記憶すればいいのでは?
    -> ポインタ値は計算には使われない

ポインタ変数
    ・元になった型の変数のアドレスを代入可能
    ・記憶しているアドレスのメモリを読んだり書き替えたりも可能
    ・ポインタ変数が指している変数を計算に用いる

普段はポインタ変数としてふるまうが、
指し示している変数の計算が必要な時は、普通の変数になる
計算時に使われるメモリはポインタ変数として記憶したアドレス



```
- ポインタ変数を使ってみる
```c
#include <stdio.h>

int main(void){
    // int* p, qとすると、qは普通のintになる
    //int *p, *qなら2つともポインタ変数

    
    return 0;
}
```
- 仮想メモリ
```c
仮想メモリ:
    ・OSがメモリを管理し、多くのアプリに適切にメモリを振り分ける
    ・cgroupみたいなものか
    ・メモリが被らないようにしているのだ
    ・つまり適当なアドレス番号だと、異常動作判定->強制終了を食らう
```
- ポインタ変数のテスト
- ※ポインタ変数も宣言直後は適当な値が代入されているので、ヌルポインタを指定して、まだ使えないことを明示しておく
```c
#include <stdio.h>

int main(void){
    //これでポインタ変数pはiと同じアドレスを指し示すことになった
    //ほとんどのコンパイラではNULLの代わりに、0でもヌルポインタが代入される
    int *p = NULL;
    int i;
    p = &i;

    printf("p=%p\n", p);
    printf("&i=%p\n", &i);

    return 0;
}
```
- 通常変数と同様のふるまいをするように切り替える
```c
#include <stdio.h>

int main(void){

    int *p = NULL;
    int i;
    p = &i;
    *p = 10; //通常変数として使用
    // iと*pは同じメモリ領域を操作可能
    printf("*p = %d\n", *p);
    printf("i = %d\n", i);
    return 0;
}
```
- まとめ
```
・ポインタ変数モードの際に、読み書きしたいメモリのアドレスを代入し、
　その後、通常変数モードに切り替えて、該当メモリを操作する

・ポインタ変数はショートカットのようなもの
・C言語のポインタは自動でないため、制御構造を仕組みが見える形で実装可能

※ポインタ変数宣言時の[*]と、関節参照演算子である[*]はまったく別の意味
```
- ポインタ型の引数
```
・戻り値を使って情報を返す場合、1つの情報しか返せない(tupleとかないのかな?)
・その場合、ポインタ型の引数を使って情報を返す
・C言語では関数へ情報を渡す場合、必ず元の変数の値のコピーが渡される（値渡し）
・ポインタ型であってもそれは同じ
・しかし、アドレスをコピーして渡し、そのアドレスを関数側でポインタ変数に代入すれば、参照しているのと同じことになる
```
- 例
```c
#include <stdio.h>

void func(int *p_value);

int main(void){
    int value = 10;
    printf("&value = %p\n", &value);
    func(&value);
    printf("value = %d\n", value);
    return 0;
}

void func(int *p_value){
    //アドレス値がコピーして渡される
    printf("p_value = %p\n", p_value);
    //通常変数モードで代入
    *p_value = 100;
    return;
}
```
- 配列型の例
```c
#include <stdio.h>
//変数名を省略する場合、(int[], int)
int get_average(int data[], int len);
int main(void){
    int average, array[10] = { 15, 78, 98, 15, 98, 85, 17, 35, 42, 15 };
    
    //配列の場合、アドレスを渡しているので関数内で値を変更すると、呼び出し元も変化する
    //アドレスを渡しているので要素数は無視される
    //仮引数内でのdata[10], data[], *dataはすべて同じものを意味する
    //本来は*dataで、data[10], data[]のような書き方も許されている
    //配列のサイズを指定してもdata[10]、要素を書かずともdata[]ポインタが渡されるのは変わりない
    int length = sizeof(array) / sizeof(array[0]);
    average = get_average(array, length);
    printf("%d\n", average);
    printf("array[3] = %d\n", array[3]);
    return 0;
}

int get_average(int data[], int len){
    int average = 0;
    for(int i=0; i<len; i++){
        average += data[i];
    }
    data[3] = 111;

    return average / 10;
}
```
- ポインタ変数なのに、以下の記述ができるのはなぜか?
```c
#include <stdio.h>

int getaverage(int *data);

int main(void){
    int average, array[10] = {15, 78, 98, 15, 98, 85, 17, 35, 42, 15};
    average = getaverage(array);
    printf("%d\n", average);
    return 0;
}

int getaverage(int *data){
    int average = 0;
    
    for (int i = 0; i < 10; i++){
        average += data[i]; /* ポインタ変数なのに？ */
    }

    return average / 10;
}
```
- 理由
```
・dataはポインタ変数であり、配列名ではないが
　そもそも配列名自体が、配列の先頭要素へのアドレス（ポインタ）として解釈されている
・どちらも配列名のアドレスにindex分の足し算を行っているだけ
・[]はそのアドレスに番号の数だけ足し算を行う
・配列を実現する手段としてポインタを利用しているので似たようなことができるだけ
・配列は指定した個数の変数の先頭を示す固定された変数であり、ポインタ変数は好きなアドレスを代入し、好きなメモリ領域を使える可変的な変数。
```
- ポインタ変数を配列のように使用する例
```c
#include <stdio.h>

int main(void){
    int *data;
    int average = 0;
    int array[5] = {7,9,10,2,17};

    data = array;
    for (int i=0; i<5; i++){
        average += data[i];
    }
    average /= 5;
    printf("%d\n", average);
    return 0;
}
```
- ポインタ変数の場合、専用の書き方がある
- ポインタ演算
```
* (ポインタ変数　+ 要素番号)
つまり、ポインタ変数のアドレス値に要素番号分の足し算を行う
それから通常変数モードに切り替え、メモリにアクセスする
```
- 例
```c
#include <stdio.h>

int main(void){

    int *data;
    int average = 0;
    int array[5] = {7,16,5,8,11};
    data = array;

    for (int i=0; i<5; i++){
        //ポインタ変数が指す型のサイズだけ増える
        average += *(data + i);
    }

    printf("%d\n", average / 5);

    return 0;
}
```
- 昔よくあった書き方
```c
#include <stdio.h>

int main(void){
    int *data;
    int average = 0;
    int array[5] = {7,16,5,8,11};

    //初期値として、配列の先頭のidxをポインタ変数に代入
    //array[5]のアドレス値になるまで、dataが指すアドレスをポインタが指す型の分だけ増やす
    for (data = array; data != &array[5]; data++){
        average += *data;
    }

    printf("%d\n", average / 5);
    return 0;
}
```
- ポインタ演算について
```
現代のコンパイラは[]でアクセスしているようなループを
自動的に++で増加するポインタ演算のような書き方に置き換えて
コンパイルしてくれるので、わかりにくい書き方をする必要はない

しかし......
組み込みの場合は最適化が機能しない場合があるので、
その場合にポインタ演算は今でも使用されることがある

```
- まとめ
```
ポインタ変数はアドレスを記憶するためのものであり、
&をつけた変数や配列名のアドレスなどを受け取り、
また、*をつけることで、アドレス内の値を操作する
値が操作されると、同じアドレスを参照している変数の値は当然変化する

```

## 練習問題15
### 1
```
A. アドレス
A. ポインタ
```
### 2
```
valueのアドレスのコピーを、関数の引数としてポインタ変数に渡し、
関数内で、アドレスの中身を変更しているため
```

### 3
```c
#include <stdio.h>

void max_min(int array[], int *max, int *min);

int main(void){
    int array[10];
    int max, min;
    int cnt = 0;
    //-1で入力終了と判断
    //0~100までしか入力されない
    //10個までしか入力されない前提
    do{
        printf("%d番目:", cnt + 1);
        scanf("%d", &array[cnt]);
        cnt++;
    }while (array[cnt-1] != -1);

    max_min(array, &max, &min);
    printf("最大値:%d, 最小値:%d", max, min);
    return 0;
}

void max_min(int array[], int *max, int *min){
    *min = 200;
    *max = -100;
    for (int i=0;; i++){
        if (array[i] == -1){
            return;
        }
        if(array[i] < *min){
            *min = array[i];
        }
        if (array[i] > *max){
            *max = array[i];
        }
    }
    return;
}
```

### 4
```
まとめに書いたので省略
```